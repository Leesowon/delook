---
title: 'React 성능 최적화 기법 - 메모이제이션(Memoization)'
type: 'concept'
language: 'React'
tags:
  - Performance
  - Optimization
  - Memoization
  - Hooks
dateModified: 2025.09.02
---

# 메모이제이션(Memoization)

> 동일한 계산을 반복해야 하는 경우, **이전에 계산한 값**을 메모리에 저장해두었다가 꺼내 쓸 수 있도록 하는 **최적화 기법**입니다.

이는 **캐시(Cache)** 개념과 유사합니다. 함수를 호출할 때 입력-결과 값을 쌍으로 저장하고, 동일한 입력이 들어왔을 때 저장된 결과를 즉시 반환합니다.


## React에서의 메모이제이션
React에서는 렌더링 성능 최적화를 위해 크게 세 가지 기법을 제공합니다.

### 1. React.memo
**컴포넌트 전체**를 메모이제이션하여 props가 변경되지 않으면 리렌더링을 건너뜁니다.
- **주요 목적**: 컴포넌트의 **불필요한 리렌더링**을 방지하여 전체적인 렌더링 성능을 개선합니다.
```typescript
// props가 변경되지 않으면 리렌더링하지 않음
const PetList = React.memo(({ data, type, age }) => {
  return (
    <div>
      {data.map(pet => <PetCard key={pet.id} pet={pet} />)}
    </div>
  );
});
```


### 2. useMemo
컴포넌트 내부의 **특정 값이나 계산 결과**를 메모이제이션하여 의존성 배열이 변경되지 않으면 재계산을 건너뜁니다.
- **주요 목적**: 복잡한 계산 과정이나 새로운 객체/배열 생성을 방지하여 계산 비용을 절약합니다.
```typescript
function SearchPage({ data, page }) {
  // 페이지네이션 계산 결과를 메모이제이션
  const paginatedData = useMemo(() => {
    const itemsPerPage = 20;
    const start = (page - 1) * itemsPerPage;
    return data.slice(start, start + itemsPerPage);
  }, [data, page]); // data나 page가 변경될 때만 재계산

  const totalPages = useMemo(() => {
    return Math.ceil(data.length / itemsPerPage);
  }, [data]);

  return <PetList data={paginatedData} />;
}
```


### 3. useCallback
**함수의 참조값**을 메모이제이션하여 의존성 배열이 변경되지 않으면 동일한 함수 참조를 유지합니다.
- **주요 목적**: 함수가 props로 전달될 때 **참조값 변경**으로 인한 **불필요한 리렌더링**을 방지합니다.
```typescript
function ParentComponent({ items }) {
  const [filter, setFilter] = useState('');

  // filter가 변경되지 않으면 동일한 함수 참조 유지
  const handleItemClick = useCallback((id) => {
    const filteredItems = items.filter(item => item.name.includes(filter));
    console.log(`Clicked item ${id}`, filteredItems);
  }, [items, filter]);

  return (
    <div>
      {items.map(item => 
        <ItemComponent 
          key={item.id} 
          item={item}
          onClick={handleItemClick} 
        />
      )}
    </div>
  );
}
```

### 사용 시 주의사항
1. **과도한 사용 금지**: 모든 값을 메모이제이션하면 오히려 **메모리 사용량**이 증가할 수 있습니다.
```typescript
// 불필요한 메모이제이션 (권장하지 않음)
const simpleValue = useMemo(() => props.count + 1, [props.count]);
```

2. **의존성 배열 설정**: 의존성 배열을 정확히 설정하지 않는 경우 예상치 못한 버그가 발생할 수 있습니다.
```typescript
// 잘못된 의존성 배열
const result = useMemo(() => {
  return items.filter(item => item.category === selectedCategory);
}, [items]); // selectedCategory를 의존성에 포함하지 않음 (버그 발생)

// 올바른 의존성 배열
const result = useMemo(() => {
  return items.filter(item => item.category === selectedCategory);
}, [items, selectedCategory]);
```


### 참고자료
[리액트 렌더링 성능 최적화에 대한 고민](https://hoonlog.vercel.app/react-optimize)
